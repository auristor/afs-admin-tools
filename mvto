#!/usr/bin/perl -w
$ID = q$Id$;
#
# mvto -- Move an AFS volume from anywhere.
#
# Written by Russ Allbery <rra@stanford.edu>
# Based on code by Neil Crellin <neilc@stanford.edu>
# Copyright 1998, 1999 Board of Trustees, Leland Stanford Jr. University
#
# A smart vos move, or a vos move that assumes you know what you're doing,
# depending on your point of view.  mvto parses the output of vos examine
# for a volume to figure out where it is and then puts it where you want it.
# It also supports replicated volumes, and is able to figure out how the
# replication pattern of a volume differs from what you want it to be and
# correct it.

use vars qw($ID);
use Getopt::Long qw(GetOptions);

# Override system with something that checks return status.
use subs qw(system);
sub system {
    CORE::system (@_) == 0
        or die "$0: @_ failed (status " . ($? >> 8) . ")\n";
}

# Usage message, in case the command line syntax is wrong.
sub usage { die "Usage: $0 <vol> <server> <part> [<server> <part> ...]\n" }

# Parse our options.
my $fullpath = $0;
$0 =~ s%.*/%%;
my ($help, $justprint, $version);
Getopt::Long::config ('bundling', 'no_ignore_case');
GetOptions ('help|h'               => \$help,
            'dry-run|just-print|n' => \$justprint,
            'version|v'            => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $fullpath);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1,2]);
    $version =~ s/,v\b//;
    die $version, "\n";
}

# Volume name is always the first argument.  Pull it off and figure out
# where this volume is.
usage if (@ARGV < 3);
my $volume = shift;
usage if (@ARGV % 2 != 0);
open (VEX, "/usr/pubsw/bin/vos examine $volume |")
    or die "$0: can't fork vos examine: $!\n";
my ($size, $rwserver, $rwpart, %ro, $sites);
while (<VEX>) {
    if (/^\Q$volume\E\s+\d+ (RW|RO|BK)\s+(\d+) K\s+On-line\s*$/) {
        die "$0: $volume is $1, not RW\n" unless $1 eq 'RW';
        $size = $2;
    } elsif (/^\s+server ([^.\s]+)\.\S+ partition (\S+) RW Site\s*/) {
        die "$0: saw two RW sites for $volume\n" if $rwserver;
        $rwserver = $1;
        $rwpart = $2;
    } elsif (/^\s+server ([^.\s]+)\.\S+ partition (\S+) RO Site\s*/) {
        $ro{$1} = $2;
        $sites++;
    }
}
close VEX;
die "$0: unable to parse vos examine $volume\n" unless ($rwserver && $size);
die "$0: replicated syntax given and $volume is unreplicated\n"
    if (!$sites && @ARGV > 2);
print "$volume on $rwserver $rwpart ($size KB)\n";
for (keys %ro) { print "  replica on $_ $ro{$_}\n" }

# Now parse the first argument, which says what server to put the RW on.
my (@commands, $needrelease);
my $toserver = shift;
my $topart = shift;
$toserver = 'afssvr' . $toserver if ($toserver =~ /^\d+$/);
$topart = '/vicep' . $topart unless ($topart =~ m%^/vicep%);
die "$0: invalid partition $topart\n" if ($topart !~ m%^/vicep[a-z]$%);
if ($rwserver eq $toserver) {
    print "$volume is already on $rwserver $rwpart\n";
    if ($ro{$rwserver}) {
        delete $ro{$rwserver};
    } elsif ($sites) {
        push (@commands, [ qw(vos addsite), $rwserver, $rwpart, $volume ]);
        $needrelease++;
    }
} else {
    push (@commands, [ qw(vos move -v), $volume, $rwserver, $rwpart,
                       $toserver, $topart ]);
    push (@commands, [ qw(vos backup), $volume ]);
    if ($sites && (!$ro{$toserver} || $ro{$toserver} ne $topart)) {
        push (@commands, [ qw(vos remove), $toserver, $ro{$toserver},
                           "$volume.readonly" ]) if $ro{$toserver};
        push (@commands, [ qw(vos addsite), $toserver, $topart, $volume ]);
        $needrelease++;
    }
}

# Grab the remaining arguments, which give the desired replication.  Build a
# hash table of the servers the volume is already replicated on, and check
# the desired state against the current state.  Consider having a replica on
# the right destination server to be good enough and don't move replicas on
# the server.
my $replicas = 1;
while (@ARGV) {
    my ($server, $part) = splice (@ARGV, 0, 2);
    $server = 'afssvr' . $server if ($server =~ /^\d+$/);
    $part = '/vicep' . $part unless ($part =~ m%^/vicep%);
    die "$0: invalid partition $part\n" if ($part !~ m%^/vicep[a-z]$%);
    if ($ro{$server}) {
        print "$volume is already on $server $ro{$server}\n";
        delete $ro{$server};
    } else {
        push (@commands, [ qw(vos addsite), $server, $part, $volume ]);
        $needrelease++;
    }
    $replicas++;
}
if ($sites && $replicas < $sites) {
    die "$0: would reduce replication from $sites sites to $replicas\n";
}

# Do the volume release, if necessary.
if ($sites && $needrelease) {
    push (@commands, [ qw(vos release -v -f), $volume ]);
}

# Now clean up any remaining unwanted replicas.
for (keys %ro) {
    push (@commands, [ qw(vos remove), $_, $ro{$_}, "$volume.readonly" ]);
}

# Okay, run our commands.
print "\n";
for (@commands) {
    print "@$_\n";
    unless ($justprint) { system (@$_) }
}

__END__

############################################################################
# Documentation
############################################################################

=head1 NAME

mvto - Move an AFS volume from anywhere

=head1 SYNOPSIS

mvto I<volume> I<server> I<partition> [I<server> I<partition> ...]

=head1 DESCRIPTION

B<mvto> is a smart B<vos move> that uses B<vos examine> to determine where
the volume is currently located and how it is currently replicated.  It
essentially allows the user to say "make the volume distribution look like
this" and it will make the changes necessary to do that.  For replicated
volumes, the first server/partition pair is taken as the location of the
read/write and every additional server/partition pair is taken as a site to
put a replica.  (One replica is automatically put on the same partition as
the read/write, if any replication sites are specified, so the result will
be a replication site on every server/partition pair given.)

If the volume is already located on the same server as the destination, even
if it's on a different partition, this is considered by B<mvto> to be "good
enough" and the volume will not be moved.  Similarly with replication sites,
if there is already a replication site on that server (even on a different
partition), that replication site won't be moved or removed and will be
counted as one of the replication sites for the volume.  To move volumes
between partitions on the same server requires more finesse and special
cases since one cannot have two replicas on the same server, so it should be
done by hand.

If any details about the replication of the volume had to be changed (and
the volume is replicated), the volume will be released.  In practice, this
means that unless the volume is already located on all of the same servers
given on the command line, already has a replication site on the same
partition as the read/write, and already has the right number of replication
sites, the volume will be released if replicated.  No check is made to
ensure that the volume is safe to release; don't pass replicated volumes
that aren't safe to release to B<mvto>.

If the read/write volume has to be moved, B<mvto> will run B<vos backup> on
the volume after the move (since volume moves have a side effect of deleting
the backup volume).  Don't use this program on volumes that shouldn't have a
backup volume.

B<mvto> will happily increase the replication of a volume if it's already
replicated and more replica sites are specified on the command line than it
currently has (or if it doesn't already have a replica on the same partition
as the read/write).  It won't, however, replicate an unreplicated volume or
decrease the number of replication sites; those operations must be done by
hand.

AFS servers may be specified as just a number; all numeric server names will
have C<afssvr> prepended to them.

B<mvto> passes the verbose flag to most B<vos> commands it runs, and passes
the B<-f> flag to B<vos release>.

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Print out this documentation (which is done simply by feeding the script to
C<perldoc -t>).

=item B<-v>, B<--version>

Print out the version of B<mvto> and exit.

=item B<-n>, B<--dry-run>, B<--just-print>

Print out volume status information and the commands that B<mvto> would run,
but don't execute any of them.

=back

=head1 EXAMPLES

Move the volume ls.trip.windlord, wherever it is, to afssvr3 /vicepd:

        mvto ls.trip.windlord afssvr3 /vicepd

Move the volume ls to afssvr5 /vicepa, with replication sites on that same
partition, on afssvr6 /vicepk, and on afssvr10 /vicepb:

        mvto ls 5 a 6 k 10 b

=head1 SEE ALSO

vos(1), vos_addsite(1), vos_backup(1), vos_examine(1), vos_move(1),
vos_release(1), vos_remove(1)

=head1 AUTHOR

Russ Allbery E<lt>rra@stanford.eduE<gt>, based on a much simpler script by
Neil Crellin E<lt>neilc@stanford.eduE<gt> that only handled unreplicated
volumes.

=cut
