#!/usr/bin/perl -w
$ID = q$Id$;
#
# mvto -- Move an AFS volume from anywhere.
#
# Written by Russ Allbery <rra@stanford.edu>
# Based on code by Neil Crellin <neilc@stanford.edu>
# Copyright 1998, 1999, 2001, 2003, 2004
#    Board of Trustees, Leland Stanford Jr. University
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.
#
# A smart vos move, or a vos move that assumes you know what you're doing,
# depending on your point of view.  mvto parses the output of vos examine
# for a volume to figure out where it is and then puts it where you want it.
# It also supports replicated volumes, and is able to figure out how the
# replication pattern of a volume differs from what you want it to be and
# correct it.

##############################################################################
# Modules and declarations
##############################################################################

require 5.004;

use strict;
use vars qw($ID $JUSTPRINT $VOS);
use subs qw(system);

use Date::Parse qw(str2time);
use Getopt::Long qw(GetOptions);

# Find a usable version of vos.
($VOS) = grep { -x $_ } qw(/usr/bin/vos /usr/pubsw/bin/vos);
$VOS ||= '/usr/pubsw/bin/vos';

##############################################################################
# Overrides
##############################################################################

# We override system to honor the global $JUSTPRINT variable.  It otherwise
# works the same way as system normally does.
sub system {
    if ($JUSTPRINT) {
        print "@_\n";
        return 0;
    } else {
        CORE::system (@_) == 0
            or die "$0: @_ failed (status " . ($? >> 8) . ")\n";
    }
}

##############################################################################
# AFS information
##############################################################################

# Given a server name and a partition, fully qualify both and return them as a
# list of ($server, $partition).  Accepts - as the partition to pick the least
# loaded partition on that server, or a list of letters or letter ranges to
# pick the least loaded of the partitions on the server from that range.
sub findpartition {
    my ($server, $part) = @_;
    $server = 'afssvr' . $server if ($server =~ /^\d+$/);
    if ($part eq '.' || (length ($part) > 1 && $part =~ /^[a-z-]+$/)) {
        $part = 'a-z' if $part eq '.';
        open (INFO, "$VOS partinfo $server |") or die "$0: can't fork: $!\n";
        my @free;
        local $_;
        while (<INFO>) {
            if (m%^Free space on partition (/vicep[$part]): (\d+) K %) {
                push (@free, [ $1, $2 ]);
            } elsif (m%^Free space on partition (/vicep.)%) {
                next;
            } else {
                die "$0: vos partinfo said $_\n";
            }
        }
        @free = sort { $$b[1] <=> $$a[1] } @free;
        $part = $free[0][0];
    } else {
        $part =~ s%^(?:/?vicep)?%/vicep%;
    }
    die "$0: invalid partition $part\n" if ($part !~ m%^/vicep[a-z]$%);
    return ($server, $part);
}


# Given a volume name, determines various characteristics of the volume and
# returns them in a hash.  'size' gets the volume size in KB, 'rwserver' and
# 'rwpart' get the server and partition for the read-write volume, 'ro' gets a
# hash of server and partition values for the replicas, 'sites' gets a count
# of the number of sites the volume is replicated on, and 'unreleased' gets a
# boolean value saying whether there are unreleased changes.
sub volinfo {
    my ($volume, $checkro) = @_;
    my (%results, $rotime, $rwtime);
    open (VEX, "$VOS examine $volume |")
        or die "$0: can't fork $VOS examine: $!\n";
    local $_;
    $results{sites} = 0;
    while (<VEX>) {
        if (/^\Q$volume\E\s+\d+ (RW|RO|BK)\s+(\d+) K\s+On-line\s*$/) {
            die "$0: $volume is $1, not RW\n" unless $1 eq 'RW';
            $results{size} = $2;
        } elsif (/^\s+server ([^.\s]+)\.\S+ partition (\S+) RW Site\s*/) {
            die "$0: saw two RW sites for $volume\n" if $results{rwserver};
            $results{rwserver} = $1;
            $results{rwpart} = $2;
        } elsif (/^\s+server ([^.\s]+)\.\S+ partition (\S+) RO Site\s*/) {
            $results{ro}{$1} = $2;
            $results{sites}++;
        } elsif (/^\s+Last Update (.*)/) {
            my $tmp = $1;
            $rwtime = str2time($tmp);
        }
    }
    close VEX;
    die "$0: unable to parse vos examine $volume\n"
        unless ($results{rwserver} && $results{size});
    if ($results{sites}) {
        open (VEX, "$VOS examine $volume.readonly |")
            or die "$0: can't fork $VOS examine for readonly: $!\n";
        while (<VEX>) {
            if (/^\s+Last Update (.*)/) {
                my $tmp = $1;
                $rotime = str2time($tmp);
            }
        }
        close VEX;
        if ($rwtime > $rotime) { $results{unreleased} = 1 }
    }
    return %results;
}

##############################################################################
# Information display
##############################################################################

# Print information about a volume so that the user can see what's going to be
# moved.  Takes the volume name and a reference to the hash of volume
# information.
sub print_volinfo {
    my ($volume, $volinfo) = @_;
    print "$volume on $$volinfo{rwserver} $$volinfo{rwpart}"
        . " ($$volinfo{size} KB)";
    print " with unreleased changes" if $$volinfo{unreleased};
    print "\n";
    for (keys %{ $$volinfo{ro} }) {
        print "  replica on $_ $$volinfo{ro}{$_}\n";
    }
    print "\n";
}

##############################################################################
# Volume moving
##############################################################################

# Return a command to add a site for a volume on a given server and partition.
sub addsite {
    my ($server, $part, $volume) = @_;
    return [ $VOS, 'addsite', $server, $part, $volume ];
}

# Return a command to move a read/write volume from a given server and
# partition to another server and partition.
sub move {
    my ($volume, @locations) = @_;
    return [ $VOS, 'move', '-v', $volume, @locations ];
}

# Return a command to back up a volume.
sub backup {
    my ($volume) = @_;
    return [ $VOS, 'backup', $volume ];
}

# Return a command to remove a volume.
sub remove {
    my ($server, $part, $volume) = @_;
    return [ $VOS, 'remove', $server, $part, $volume ];
}

# Return a command to release a volume.
sub release {
    my ($volume) = @_;
    return [ $VOS, 'release', '-f', '-v', $volume ];
}

# Build the commands required to move the read/write site of a volume.  Takes
# the volume name, the volume information hash, the server to move the volume
# to, and the partition on that server to move the volume to, and returns a
# flag saying whether the volume needs a release followed by a list of
# commands, each of which is an anonymous giving a command to run.  Modifies
# the provided volinfo hash to delete the read-only replicas that have been
# accounted for.
sub move_rw {
    my ($volume, $volinfo, @location) = @_;
    my (@commands, $needrelease);
    my ($toserver, $topart) = findpartition (@location);
    my @to = ($toserver, $topart);
    my ($fromserver, $frompart) = ($$volinfo{rwserver}, $$volinfo{rwpart});
    my @from = ($fromserver, $frompart);
    my %ro = %{ $$volinfo{ro} };

    # If the read/write is already on the right server, make sure there's also
    # a replica on the same partition if the volume is replicated.  Otherwise,
    # move the read/write site and its corresponding replica if applicable.
    if ($fromserver eq $toserver) {
        print "$volume is already on $fromserver\n";
        if ($ro{$toserver}) {
            delete $$volinfo{ro}{$toserver};
        } elsif ($$volinfo{sites} > 0) {
            push (@commands, addsite (@to, $volume));
            $needrelease++;
        }
    } else {
        push (@commands, move ($volume, @from, @to));
        push (@commands, backup ($volume));
        if ($$volinfo{sites} > 0) {
            if ($ro{$toserver} && $ro{$toserver} ne $topart) {
                my $ro = "$volume.readonly";
                push (@commands, remove ($toserver, $ro{$toserver}, $ro));
            }
            if (!$ro{$toserver} || $ro{$toserver} ne $topart) {
                push (@commands, addsite (@to, $volume));
            }
        }
        $needrelease++;
    }
    return ($needrelease, @commands);
}

# Build the commands required to move the read/write site of a volume.  Takes
# the volume name, the volume information hash, and a list of server and
# partition pairs onto which to put the volume.  Returns a flag saying whether
# the volume needs a release followed by a list of commands, each of which is
# an anonymous giving a command to run.  Modifies the provided volinfo hash to
# delete the read-only replicas that have been accounted for.
sub move_ros {
    my ($volume, $volinfo, @location) = @_;
    my $replicas = 1;
    my %ro = %{ $$volinfo{ro} };
    my ($needrelease, @commands);

    # Walk the list of replica sites.  Delete out of the replica list in
    # volinfo any that are already in the right place, and generate commands
    # to move the rest.
    while (@location) {
        my ($server, $part) = findpartition (splice (@location, 0, 2));
        if ($ro{$server}) {
            print "$volume is already on $server\n";
            delete $$volinfo{ro}{$server};
        } else {
            push (@commands, addsite ($server, $part, $volume));
            $needrelease++;
        }
        $replicas++;
    }

    # Do sanity checking to make sure that we don't increase the number of
    # replicas.
    if ($$volinfo{sites} > 0 && $replicas != $$volinfo{sites}) {
        my $dir = ($replicas < $$volinfo{sites}) ? 'reduce' : 'increase';
        die "$0: would $dir replication from $$volinfo{sites}"
            . " to $replicas sites\n";
    }

    # Return the flag and the commands.
    return ($needrelease, @commands);
}

# Given a volume name, a flag saying whether to force releases, and then a
# list of server and partition pairs onto which to put it, take the necessary
# actions to move the volume.  Returns true if the move was successful.
# Otherwise, it prints a warning and returns false.
sub move_volume {
    my ($volume, $force, @location) = @_;
    my @rw = splice (@location, 0, 2);
    my @ro = @location;

    # Get and display information about the volume.
    my %volinfo = volinfo ($volume);
    print_volinfo ($volume, \%volinfo);

    # Make sure we're not newly replicating the volume as part of the move.
    die "$0: replica sites given and $volume is unreplicated\n"
        if (!$volinfo{sites} && @location > 2);

    # Build the list of commands to implement the move and also set the flag
    # saying whether we need to do a volume release.
    my ($needrelease, @commands) = move_rw ($volume, \%volinfo, @rw);
    my @result = move_ros ($volume, \%volinfo, @ro);
    $needrelease = shift (@result) || $needrelease;
    push (@commands, @result);

    # Refuse to release a volume with unreleased changes unless --force was
    # given on the command line.  Note that there is a race condition here, so
    # this check is not completely reliable (someone may have changed the
    # volume since after we ran vos examine).
    $needrelease &&= ($volinfo{sites} > 0);
    die "$0: volume has unreleased changes, use --force to force a release\n"
        if ($volinfo{unreleased} && $needrelease && !$force);

    # Add the volume release to the commands if necessary.
    push (@commands, release ($volume)) if $needrelease;

    # Clean up any unwanted replicas.  All wanted replicas have already been
    # deleted out of the hash.
    for (keys %{ $volinfo{ro} }) {
        push (@commands, remove ($_, $volinfo{ro}{$_}, "$volume.readonly"));
    }

    # Okay, run the commands.  In order to get our spacing correct, print out
    # a newline if there are fewer commands than the number of sites plus two,
    # since that means that at least one replica was already on the right
    # server and we printed that out.
    if (@commands < $volinfo{sites} + 2) {
        print "\n";
    }
    for (@commands) {
        print "@$_\n";
        system @$_;
    }
}

##############################################################################
# Implementation
##############################################################################

# Usage message, in case the command line syntax is wrong.
sub usage { die "Usage: $0 <vol> <server> <part> [<server> <part> ...]\n" }

# Trim extraneous garbage from the path.
my $fullpath = $0;
$0 =~ s%.*/%%;

# Make sure we get output in the right order.
$| = 1;

# Parse our options.
my ($help, $force, $list,$version);
Getopt::Long::config ('bundling', 'no_ignore_case');
GetOptions ('help|h'               => \$help,
            'force|f'              => \$force,
            'list|l=s'             => \$list,
            'dry-run|just-print|n' => \$JUSTPRINT,
            'version|v'            => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $fullpath);
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    $version =~ tr%/%-%;
    print $version, "\n";
    exit 0;
}

# Volume name is always the first argument unless -l was given, and the rest
# of our arguments must be server and partition pairs.
my $volume;
unless ($list) {
    usage if (@ARGV < 3);
    $volume = shift;
}
usage if (@ARGV % 2 != 0);

# Do the work.  If -l was given, this means looping on the volumes listed in
# that file; otherwise, just move the single volume.
if ($list) {
    open (LIST, $list) or die "$0: cannot open $list: $!\n";
    my @volumes = <LIST>;
    close LIST;
    chomp @volumes;
    my $total = scalar @volumes;
    my $i = 0;
    for (@volumes) {
        $i++;
        print "MOVING $_ ($i of $total)\n\n";
        move_volume ($_, $force, @ARGV);
        print "\n";
        print "\n" unless ($i == $total);
    }
    print "FINISHED $list\n";
} else {
    move_volume ($volume, $force, @ARGV);
}

__END__

##############################################################################
# Documentation
##############################################################################

=head1 NAME

mvto - Move an AFS volume from anywhere

=head1 SYNOPSIS

mvto [B<-hfnv>] I<volume> I<server> I<partition> [I<server> I<partition> ...]

mvto [B<-hfnv>] [B<-l> I<list> I<server> I<partition>
[I<server> I<partition> ...]

=head1 DESCRIPTION

B<mvto> is a smart B<vos move> that uses B<vos examine> to determine where
the volume is currently located and how it is currently replicated.  It
essentially allows the user to say "make the volume distribution look like
this" and it will make the changes necessary to do that.  For replicated
volumes, the first server/partition pair is taken as the location of the
read/write and every additional server/partition pair is taken as a site to
put a replica.  (One replica is automatically put on the same partition as
the read/write, if any replication sites are specified, so the result will
be a replication site on every server/partition pair given.)

If the volume is already located on the same server as the destination, even
if it's on a different partition, this is considered by B<mvto> to be "good
enough" and the volume will not be moved.  Similarly with replication sites,
if there is already a replication site on that server (even on a different
partition), that replication site won't be moved or removed and will be
counted as one of the replication sites for the volume.  To move volumes
between partitions on the same server requires more finesse and special
cases since one cannot have two replicas on the same server, so it should be
done by hand.

If any details about the replication of the volume had to be changed (and
the volume is replicated), the volume will be released.  In practice, this
means that unless the volume is already located on all of the same servers
given on the command line, already has a replication site on the same
partition as the read/write, and already has the right number of replication
sites, the volume will be released if replicated.

If the volume needs to be released, B<mvto> will check to see if it has any
unreleased changes.  If so, it will refuse to perform any operations unless
the B<--force> (or B<-f>) command-line option is given to avoid accidentally
releasing volumes with unreleased changes.  Don't rely on this check
completely, since the volume could be modified between when B<mvto> checks
and when it actually releases the volume.

If the read/write volume has to be moved, B<mvto> will run B<vos backup> on
the volume after the move (since volume moves have a side effect of deleting
the backup volume).  Don't use this program on volumes that shouldn't have a
backup volume.

B<mvto> will neither increase nor decrease the replication of a volume.  If
the number of replication sites should be changed, or if the volume is
currently unreplicated and should be replicated, this should be done by hand
before running B<mvto>, using B<vos addsite> and B<vos remove>.

AFS servers may be specified as just a number; all numeric server names will
have C<afssvr> prepended to them.

As with all AFS commands, partitions may be specified as a simple letter, as
C<vicepX>, or as C</vicepX>.  More than 26 partitions on one server is not
supported.  Partitions may also be specified as C<.>, in which case the
parition on that server with the most free space according to B<vos
partinfo> is chosen, or as a string of letters and letter ranges such as
C<ace-gm>, in which case the partition of the set specified with the most
free space is chosen.  (In this example, the set is /vicepa, /vicepc,
/vicepe through /vicepg, or /vicepm on the given sever.)

B<mvto> passes the verbose flag to most B<vos> commands it runs, and passes
the B<-f> flag to B<vos release>.

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Print out this documentation (which is done simply by feeding the script to
C<perldoc -t>).

=item B<-f>, B<--force>

Release a volume if a release is required, even if that volume has
unreleased changes.  Without this flag, B<mvto> will refuse to release a
volume that has unreleased changes.

=item B<-l> I<list>, B<--list>=I<list>

Rather than take a single volume name on the command line, read in a list of
volumes to act on from the file I<list>.  I<list> should contain a simple
list of AFS volume names, one per line, and each volume will be moved as if
it were specified on the B<mvto> command line, using the location
information given on the command line.

=item B<-n>, B<--dry-run>, B<--just-print>

Print out volume status information and the commands that B<mvto> would run,
but don't execute any of them.

=item B<-v>, B<--version>

Print out the version of B<mvto> and exit.

=back

=head1 EXAMPLES

Move the volume ls.trip.windlord, wherever it is, to afssvr3 /vicepd:

    mvto ls.trip.windlord afssvr3 /vicepd

Move the volume ls to afssvr5 /vicepa, with replication sites on that same
partition, on afssvr6 /vicepk, and on afssvr10 /vicepb:

    mvto ls 5 a 6 k 10 b

Move the volume pubsw to the partition on afssvr10 with the most free
space, with one replication site on afssvr11 on whichever partition of the
first three has the most free space.  This volume will be released even if
it has unreleased changes.

    mvto -f pubsw 10 . 11 a-c

Move all of the volumes in the file F<evacuate> to the most empty partition
on afssvr9.  Note that the check for the most empty partition is done anew
for each individual volume move, so the volumes will be spread out across
the server.

    mvto -l evacuate afssvr9 .

=head1 SEE ALSO

vos(1), vos_addsite(1), vos_backup(1), vos_examine(1), vos_move(1),
vos_release(1), vos_remove(1)

The current version of this program is available from its web page at
L<http://www.eyrie.org/~eagle/software/mvto/>.

=head1 AUTHORS

Russ Allbery <rra@stanford.edu>, based on a much simpler script by Neil
Crellin <neilc@stanford.edu> that only handled unreplicated volumes.

=head1 COPYRIGHT AND LICENSE

Copyright 1998, 1999, 2001, 2003, 2004 Board of Trustees, Leland Stanford
Jr. University.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
