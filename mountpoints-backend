#!/usr/bin/perl -w
$ID = q$Id$;
#
# mountpoints-backend -- remctl backend script for AFS mountpts maintenance.
#
# Written by Jon Robertson <jonrober@stanford.edu>
# Taken heavily from mtpt and cleanmtpts, by Russ Allbery <rra@stanford.edu>
# Copyright 2008 Board of Trustees, Leland Stanford Jr. University
#
# This program is a frontend to the afs database, specifically the
# mountpoints table there.  It allows mountpoints to be added, removed,
# listed, and cleaned.

# Contains the functions from mtpt (mtpt and count)
# Contains the functions from cleanmtpts (cleanmtpts)

##############################################################################
# Site configuration
##############################################################################

# Use the existing K5 service/lsdb ticket maintained by kstart.
$ENV{KRB5CCNAME} = "/var/run/lsdb.k5.tgt";

# The full path to aklog, used to obtain AFS tokens from a Kerberos ticket.
$AKLOG          = '/usr/bin/aklog';

# The full path to fs.  Allow for Linux where the preferred location may be
#  on local disk.
($FS)  = grep { -x $_ } qw(/usr/bin/fs /usr/afsws/bin/fs /usr/pubsw/bin/fs);
$FS ||= '/usr/afsws/bin/fs';

##############################################################################
# Modules and declarations
##############################################################################

require 5.005;

use strict;
use vars qw($AKLOG $ID $FS);

use AFS::Utils qw(setpag unlog);
use Stanford::LSDB::AFSDB;

##############################################################################
# Mount point checking
##############################################################################

# The following function is used to convert paths to a canonical form.  You
# will almost certainly want to change this for your site.
sub canonify_path {
    my ($path) = @_;
    $path =~ s%^/chroot/afs/%/afs%;
    $path =~ s%^/afs/\.?ir(?:\.stanford\.edu)?/%/afs/.ir/%;
    return unless ($path =~ m%^/afs/\.ir/% || $path eq '/afs');
    return $path;
}

# Given a path, make sure it's fully qualified and doesn't contain any invalid
# characters.
sub fix_path {
    my ($path) = @_;
    return unless $path =~ m%^/afs%;
    $path = canonify_path($path);
    return unless $path;
    return if $path =~ /[\\\';]/;
    $path =~ s%/+$%%;
    return $path;
}

# Given a path, return the volume mounted on that path or undef if it does not
# appear to be a mount point (or on any other failure).
sub path_to_volume {
    my ($path) = @_;
    my $volname;
    if ($path eq '/afs') {
        $volname = 'root.afs';
    } else {
        $volname = `$FS lsmount '$path' 2>&1`;
        my $ismtpt = ($? == 0);
        return unless $ismtpt;
        $volname =~ s/.*a mount point for volume \'\#(\S+)\'\s+$/$1/;
    }
    return $volname;
}

# Check a single mount point, canonifying if necessary and making sure that
# it's still valid.  Remove mount point mappings that are no longer valid.
# Special-case /afs and root.afs, since fs lsm may not return the right
# results there.  Returns the number of deletions done.
sub check_mount {
    my ($volume, $mtpts) = @_;
    my $path = $$mtpts{$volume}{'path'};
    my $newpath = fix_path($path);
    if (!$newpath) {
        print "REMOVING $volume => $path (bad path)\n";
        delete_mount($volume);
        return 1;
    } else {
        my $real = path_to_volume($newpath);
        if (!$real || $real ne $volume) {
            print "REMOVING $volume => $path\n";
            delete_mount($volume);
            return 1;
        } elsif ($path ne $newpath) {
            print "CANONIFYING $volume => $newpath\n";
            update_mount($volume, 'path', $newpath);
        }
        return 0;
    }
}

# Go through the mounts and verify that each still exists and has the correct
#  path information.  If given a list of volume names, only check those names.
#  Otherwise, check all volumes in the mountpoint database.
sub clean_mtpt {
    my (@check_mounts) = @_;

    my %mtpts = find_all_mounts();

    # If we're given a list of volumes on the command line, process those.
    # Otherwise, process every volume in the database.  The duplication of code
    # is annoying here, but I don't see a good way to avoid it without reading
    # all the volumes in the database into memory.
    my ($count, $deletes) = (0, 0);
    @check_mounts = keys %mtpts unless @check_mounts;
    for my $volume (@check_mounts) {
        next unless exists $mtpts{$volume};
        $deletes += check_mount ($volume, \%mtpts);
    } continue {
        $count++;
        print "$count entries processed\n" if ($count % 1000 == 0);
    }
    print "$count entries total processed\n";
    print "$deletes entries deleted\n";
}

##############################################################################
# Database operations
##############################################################################

# Check to see if a mountpoint already has a database entry.  If so, return
#  the path.
sub mount_exists {
    my ($volname) = @_;

    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "SELECT path FROM mountpoints WHERE volname=" .
        $dbh->quote($volname);
    my $sth = $dbh->prepare($query);
    $sth->execute();

    if (my $ref = $sth->fetchrow_hashref()) {
#        print $ref->{'path'};
        return 1;
    }

    die "$0: error checking for existance of $volname\n" if $@;
    $dbh->disconnect();
    return 0;
}

# Return a hash of all mountpoint data, with volname as the key.
sub count_mounts {
    my $count = 0;

    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "SELECT count(*) FROM mountpoints";
    my $sth = $dbh->prepare($query);
    $sth->execute();

    if (my $ref = $sth->fetchrow_hashref()) {
        $count = $ref->{'count(*)'};
    }

    die "$0: error counting mountpoints \n" if $@;
    $sth->finish();
    $dbh->disconnect();

    return $count;
}

# Return a hash of all mountpoint data, with volname as the key.
sub find_all_mounts {
    my (%mounts);

    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "SELECT * FROM mountpoints ORDER BY volname";
    my $sth = $dbh->prepare($query);
    $sth->execute();

    while (my $ref = $sth->fetchrow_hashref()) {
        my $volname = $ref->{'volname'};
        $mounts{$volname}{'path'}  = $ref->{'path'};
        $mounts{$volname}{'volid'} = $ref->{'volid'};
    }

    die "$0: error finding all mountpoints \n" if $@;
    $dbh->disconnect;

    return %mounts;
}

# Return a hash of all mountpoint data, with volname as the key.
sub find_mount {
    my ($volname) = @_;
    my (%mounts);

    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "SELECT * FROM mountpoints WHERE volname=".
        $dbh->quote($volname);
    my $sth = $dbh->prepare($query);
    $sth->execute();

    while (my $ref = $sth->fetchrow_hashref()) {
        my $volname = $ref->{'volname'};
        $mounts{$volname}{'path'}  = $ref->{'path'};
        $mounts{$volname}{'volid'} = $ref->{'volid'};
    }

    die "$0: error finding all mountpoints \n" if $@;
    $dbh->disconnect;

    return %mounts;
}

# Store a new mountpoint in the database.
sub store_mount {
    my ($volname, $path, $volid) = @_;

    # Insert the entry into the database.
    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "INSERT INTO mountpoints VALUES (?, ?, ?)";
    $dbh->do($query, undef, $volname, $path, $volid);

    die "$0: error adding $volname to mountpoints\n" if $@;
    $dbh->disconnect;
    return 1;
}

# Delete a mount point from the database.
sub delete_mount {
    my ($volname) = @_;

    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "DELETE FROM mountpoints WHERE volname=?";
    $dbh->do($query, undef, $volname);

    die "$0: error deleting $volname from mountpoints\n" if $@;
    $dbh->disconnect;
    return 1;
}

# Updates a single field in the database for a mount.
sub update_mount {
    my ($volname, $field, $value) = @_;
    my $dbh = Stanford::LSDB::AFSDB->connect
        or die "Cannot connect to the AFS database\n";
    my $query = "UPDATE mountpoints SET $field=? WHERE volname=?";
    $dbh->do($query, undef, $value, $volname);

    die "$0: error deleting $volname from mountpoints\n" if $@;
    $dbh->disconnect;
    return 1;
}

##############################################################################
# Misc operations
##############################################################################

# Change the settings of an existing mount.  Simply do two changes, one for
#  path and one for volid.
sub change_mount {
    my ($volname, $path, $volid) = @_;

    return update_mount($volname, 'path', $path)
        && update_mount($volname, 'volid', $volid);
}

# Print out all existing mountpoints.  Simply grab from the general find
#  subroutine for this, then print out prettily.
sub dump_mounts {
    my (%mounts) = find_all_mounts();
    print "No mounts found!\n" unless %mounts;
    foreach my $volname (sort keys %mounts) {
        print $volname, "\t", $mounts{$volname}{'path'}, "\t",
              $mounts{$volname}{'volid'}, "\n";;
    }
    return 1;
}

# Show the mount points for a number of mountpoints given us.
sub list_mounts {
    my (@search_mounts) = @_;

    for my $volname (@search_mounts) {
        my (%mounts) = find_mount($volname);
        if (exists $mounts{$volname}) {
            my $path = $mounts{$volname}{'path'};;
            print "$path\n";
        } else {
            warn "$0: mountpoint for $volname not currently recorded\n";
        }
    }
    return 1;
}

# Print out the total number of mountpoints.  Grab all mounts and give the
#  count.  Not the most efficient way, but works with existing bits.
sub count_mtpts {
    my $total = count_mounts();
    print "$total entries total\n";
    return 1;
}

##############################################################################
# Main routine
##############################################################################

# Acquire an AFS token.
setpag or die "$0: unable to setpag: $!\n";
system ($AKLOG) == 0 or die "$0: unable to obtain tokens\n";

# Parse the command line.
my $action = shift;
if (!defined $action || $action eq '' || $action eq 'help') {
    print "  mountpoint list\n";
    print "  mountpoint count\n";
    print "  mountpoint mtpt [volume] [volume]...[volume]\n";
    print "  mountpoint create <mountpoint> <path> <volid>\n";
    print "  mountpoint delete <mountpoint>\n";
    print "  mountpoint exists <mountpoint>\n";
    print "  mountpoint cleanmtpts [mountpoint]\n";
    exit 0;

} elsif ($action eq 'list') {
    exit (dump_mounts() ? 0 : 1);

} elsif ($action eq 'cleanmtpts') {
    my (@mounts) = @ARGV;
    exit (clean_mtpt(@mounts) ? 0 : 1);

} elsif ($action eq 'count') {
    exit (count_mtpts() ? 0 : 1);

} elsif ($action eq 'mtpt') {
    my (@mounts) = @ARGV;
    unless (@mounts) {
        die "$0: at least one mount point must be given\n";
    }
    exit (list_mounts(@mounts) ? 0 : 1);

} elsif ($action eq 'create') {
    my ($mount, $path, $volid) = @ARGV;
    unless ($mount) {
        die "$0: mount point, path, and volid must be given\n";
    }
    exit (store_mount ($mount, $path, $volid) ? 0 : 1);
} elsif ($action eq 'change') {
    my ($mount, $path, $volid) = @ARGV;
    unless ($mount) {
        die "$0: mount point, path, and volid must be given\n";
    }
    exit (change_mount ($mount, $path, $volid) ? 0 : 1);
} elsif ($action eq 'delete') {
    my ($mount) = @ARGV;
    unless ($mount) { die "$0: volume name must be given\n" }
    exit (delete_mount ($mount) ? 0 : 1);
} elsif ($action eq 'exists') {
    my ($mount) = @ARGV;
    unless ($mount) {
        die "$0: mount point must be given\n";
    }
    exit (mount_exists ($mount) ? 0 : 1);
} else {
    die "$0: unknown operation $action\n";
}

# Remove our AFS token just to be tidy.
unlog;

__END__

##############################################################################
# Documentation
##############################################################################

=head1 NAME

mountpoints-backend - remctl backend script for AFS mountpoint maintenance

=head1 SYNOPSIS

B<mountpoints-backend> list

B<mountpoints-backend> count

B<mountpoints-backend> mtpt I<volume> I[volume] ... I[volume]

B<mountpoints-backend> create I<volume> I<path> I<volid>

B<mountpoints-backend> delete I<volume>

B<mountpoints-backend> exists I<volume>

B<mountpoints-backend> cleanmtpts I[volume] I[volume] ... I[volume]

=head1 REQUIREMENTS

B<remctl> is required to run this script.  Any new
installation should use B<remctl>.  The AFS command B<fs> is needed, as is
the B<aklog> command.

The script relies on an existing mountpoints database, named mountpoints,
with fields volname, path, and volid.

=head1 DESCRIPTION

This script is intended to be run from remctl to perform various
administrative commands to edit the database of mountpoints.  It is meant
mostly as a backend interface to be used by other scripts such as volcreate,
than to be run directly.

There are multiple operations -- list to list all mountpoints and their
information, count to display the total number of mountpoints, mtpt to
list the paths to one or more volumes given (replicating the earlier mtpt
script), create to add a new mountpoint, delete to remove a mountpoint,
exists to check the existence of a mountpoint, and cleanmtpts to go through
the database and clean up inconsistent entries.

=head1 EXAMPLES

List the paths for several volumes:

    mountpoints-backend mtpt ls.trip.test ls.trip.example

This will return the directories where ls.trip.test and ls.trip.example are
mounted.

Create a new entry:

    mountpoints-backend create mtpt ls.trip.test \
        /afs/.ir/site/leland/tripwire/test.stanford.edu 2003034058

Add a new mountpoint with name ls.trip.test, with the mountpoint at
/afs/.ir/site/leland/tripwire/test.stanford.edu and the volid 2003034058.
This does not create the mount, only makes sure we are tracking it.

Remove an entry:

    mountpoints-backend delete ls.trip.example

This will remove the entry for the volume ls.trip.example from the database.
It does B<not> delete the volume, only remove it from volumes we are keeping
track of.

Check existence of a volume:

    mountpoints-backend exists ls.trip.example

This will see if a volume ls.trip.example exists, having the script give an
exit value of 0 if so, 1 if not.

Run through and clean volume information:

    mountpoints-backend cleanmtpts ls.trip.example ls.trip.test

This will check to make sure that the two given volumes exist in the
database.  If so, it will make sure that they still exist and that the
information for them is still accurate, deleting or changing if not.  If run
with no given volumes, it would go through every volume in the database.

=head1 FILES

=item F</usr/local/bin/aklog>

The path to the program to run to obtain AFS tokens from a ticket cache.

=item F</var/run/lsdb.k5.tgt>

The expected path to a K5 ticket cache for an identity that has the ability
to create, release, and remove AFS volumes and set volume quota.  It should
be in both system:administrators and in F<UserList> on the AFS servers.

B<fs> is searched for in F</usr/bin>, then in F</usr/afsws/bin>, and then
in F</usr/pubsw/bin>.

=head1 AUTHOR

Jon Robertson <jonrober@stanford.edu>
From bits of cleanmtpts and mtpt by Russ Allbery <rra@stanford.edu>

=head1 COPYRIGHT AND LICENSE

Copyright 2008 Board of Trustees, Leland Stanford Jr. University.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

B<k5start> is recommended for maintaining a ticket cache.  It can be
obtained from its web page at L<http://www.eyrie.org/~eagle/software/kstart/>.

=cut
