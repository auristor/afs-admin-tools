#!/usr/bin/perl -w
$ID = q$Id$;
#
# volcreate -- Create a volume, mount and set acl and quota
#
# Written by Neil Crellin <neilc@stanford.edu>
#        and Russ Allbery <rra@stanford.edu>
# Copyright 1998, 1999, 2000, 2002, 2004
#     Board of Trustees, Leland Stanford Jr. University
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.
#
# Creates a new AFS volume on the given server and partition and mounts it
# in the file system, setting default ACLs if appropriate.  It then calls
# loadmtpt to update the mount point database.

##############################################################################
# Site configuration
##############################################################################

# The path to a file containing a list of current AFS servers and their volume
# types.  See the documentation for its format.
$SERVERS = '/afs/ir/service/afs/data/serverlist.types';

# The path to a file containing ACL rules for volumes.  See the documentation
# for its format.
$ACLS = '/afs/ir/service/afs/data/acl-rules';

# The full path to the loadmtpt utility.
$LOADMTPT = '/afs/ir/service/afs/scripts/loadmtpt';

# The full path to fs and vos.  Allow for Linux where the preferred location
# may be on local disk.
($FS)  = grep { -x $_ } qw(/usr/bin/fs /usr/afsws/bin/fs /usr/pubsw/bin/fs);
$FS ||= '/usr/afsws/bin/fs';
($VOS) = grep { -x $_ } qw(/usr/bin/vos /usr/pubsw/bin/vos);
$VOS ||= '/usr/pubsw/bin/vos';

##############################################################################
# Modules and declarations
##############################################################################

require 5.005;

use strict;
use vars qw($ACLS $FS $ID $JUSTPRINT $LOADMTPT $SERVERS $VOS);
use subs qw(system);

use Getopt::Long qw(GetOptions);

##############################################################################
# Overrides
##############################################################################

# We override system to honor the global $JUSTPRINT variable.  It otherwise
# works the same way as system normally does.
sub system {
    if ($JUSTPRINT) {
        print "@_\n";
        return 0;
    } else {
        return CORE::system (@_);
    }
}

##############################################################################
# AFS information
##############################################################################

# Given a list of server name and partition pairs, fully qualify each and
# return them as a list of similar pairs, ordered by whichever partition has
# the most percentage free space.  If ., a list of letters, or letter ranges
# are given for the partition, pick the partition from that set that has the
# most free space.
sub find_targets {
    my @locations = @_;
    my @results;

    # Special-case the fully-qualifed case where the user gave the exact
    # server and partition.
    if (@locations == 1 && $locations[0][1] =~ /^[a-z]$/) {
        my ($server, $partition) = @{ $locations[0] };
        $server = 'afssvr' . $server if ($server =~ /^\d+$/);
        $partition =~ s%^(?:/?vicep)?%/vicep%;
        return [ $server, $partition ];
    }

    # The normal case, where we need to go looking at current server usage to
    # gather the necessary information.
    while (@locations) {
        my ($server, $part) = @{ shift @locations };

        $server = 'afssvr' . $server if ($server =~ /^\d+$/);
        $part = 'a-z' if $part eq '.';
        open (INFO, "$VOS partinfo $server |") or die "$0: can't fork: $!\n";
        my @free;
        local $_;
        while (<INFO>) {
            if (m(^Free\ space\ on\ partition\ (/vicep[$part]):\ (\d+)\ K
                  \ blocks\ out\ of\ total\ (\d+)\s*\z)x) {
                push (@free, [ $1, $2, $2 / $3 ]);
            } elsif (m%^Free space on partition (/vicep.)%) {
                next;
            } else {
                die "$0: vos partinfo said $_\n";
            }
        }
        close INFO;
        if (!@free) { die "$0: no partition matching $part on $server\n" }
        @free = sort { $$b[1] <=> $$a[1] } @free;
        push (@results, [ $server, $free[0][0], $free[0][2] ]);
    }
    @results = sort { $$b[2] <=> $$a[2] } @results;
    return map { [ $$_[0], $$_[1] ] } @results;
}

# Given a volume type for an unreplicated volume, look through the types file
# and find appropriate servers and partitions to use.  Returns the server and
# partition pair that has the most percentage free space.
sub find_best_normal {
    my $type = shift;
    my @locations;
    open (SERVERS, $SERVERS) or die "$0: can't open $SERVERS: $!\n";
    local $_;
    while (<SERVERS>) {
        my ($server, @rules) = split;
        shift @rules if ($rules[0] =~ /^\[.*\]$/);
        my $parts = '';
        for (@rules) {
            my ($part, $allowed);
            if (/:/) {
                ($part, $allowed) = split ':';
            } else {
                $part = 'a-z';
                $allowed = $_;
            }
            if ($allowed eq $type) {
                $parts .= $part;
            }
        }
        if ($parts) {
            push (@locations, [ $server, $parts ]);
        }
    }
    close SERVERS;
    if (!@locations) {
        die "$0: no servers found for type $type\n";
    }
    return @{ (find_targets @locations)[0] };
}

# Given a volume type for a replicated volume and the number of replicas, look
# through the types file and find appropriate servers and partitions to use.
# Returns a list, where the first two elements are the server and partition to
# use for the read/write and the first replica and subsequent element pairs
# are the server and partition to use for the read-only replicas.  Handles
# geographic dispersion.
sub find_best_replicated {
    my ($type, $replicas) = @_;
    my (@rw, @ro, %servers);
    open (SERVERS, $SERVERS) or die "$0: can't open $SERVERS: $!\n";
    local $_;
    while (<SERVERS>) {
        my ($server, @rules) = split;
        my $site;
        if ($rules[0] =~ /^\[(.*)\]$/) {
            $site = $1;
            shift @rules;
        }
        my $rwparts = '';
        my $roparts = '';
        for (@rules) {
            my ($part, $allowed);
            if (/:/) {
                ($part, $allowed) = split ':';
            } else {
                $part = 'a-z';
                $allowed = $_;
            }
            if ($allowed eq "$type-rw") {
                $rwparts .= $part;
            } elsif ($allowed eq "$type-ro") {
                $roparts .= $part;
            }
        }
        if ($rwparts) {
            $servers{$server} = $site;
            push (@rw, [ $server, $rwparts ]);
        }
        if ($roparts) {
            $servers{$server} = $site;
            push (@ro, [ $server, $roparts ]);
        }
    }
    close SERVERS;
    if (!@rw || !@ro || @ro < $replicas - 1) {
        die "$0: insufficient servers found for type $type\n";
    }
    my @locations;
    push (@locations, (find_targets @rw)[0]);
    my %sites = map { $_ => 1 } values %servers;
    for my $site (keys %sites) {
        last if @locations >= $replicas;
        next if $site eq $servers{$locations[0][0]};
        my @candidates = grep { $servers{$$_[0]} eq $site } @ro;
        next unless @candidates;
        push (@locations, (find_targets @candidates)[0]);
    }
    my $found = @locations;
    if ($found < $replicas) {
        my %locations = map { @$_ } @locations;
        @ro = grep { !$locations{$$_[0]} } @ro;
        push (@locations, (find_targets @ro)[0 .. ($replicas - $found - 1)]);
    }
    return @locations;
}

##############################################################################
# AFS operations
##############################################################################

# Create a volume, given the server, partition, volume name, and quota.  Dies
# on a failure to create the volume.
sub volume_create {
    my ($server, $partition, $volume, $quota) = @_;
    system ($VOS, 'create', $server, $partition, $volume, $quota * 1000) == 0
        or die 'Failed to create volume (status ', ($? >> 8), ")\n";
}

# Clone a volume, given the server, partition, and volume name to use for the
# new volume and the name of the old volume to clone.
sub volume_clone {
    my ($server, $partition, $new, $old) = @_;
    require File::Temp;
    my ($fh, $filename) = File::Temp::tempfile (undef, UNLINK => 1);
    print "Dumping volume $old\n";
    system ($VOS, 'dump', '-id', $old, '-file', $filename) == 0
        or die "$0: failed to dump volume $old (status ", ($? >> 8), ")\n";
    print "Restoring $new from ", $filename, "\n";
    system ($VOS, 'restore', '-server', $server, '-partition', $partition,
            '-name', $new, '-file', $filename) == 0
        or die "$0: failed to create volume $new (status ", ($? >> 8), ")\n";
    close $fh;
}

# Mount the volume, chmod it to 755 since AFS creates it 777, and load the
# mount point into the database.  chmod the root of the volume to 755 since
# AFS creates it 777.
sub volume_mount {
    my ($volume, $mtpt) = @_;
    system ($FS, 'mkm', $mtpt, $volume) == 0
        or die 'Failed to make mount point (status ', ($? >> 8), ")\n";
    if ($JUSTPRINT) {
        print "chmod 755 $mtpt\n";
    } else {
        chmod (0755, $mtpt) or warn "Failed to chmod root: $!\n";
    }
    system ($LOADMTPT, $mtpt) == 0
        or warn 'Failed to load mountpoint (status ', ($? >> 8), ")\n";
}

# Set the ACLs of the volume appropriately.  Some volumes have their own
# particular ACL conventions; take care of those here as well.
sub volume_setacls {
    my ($volume, $mtpt, @acls) = @_;

    # Find any extra ACLs that apply to this volume.
    my @extra;
    if (open (ACLS, $ACLS)) {
        local $_;
        my $found = 0;
        while (<ACLS>) {
            next if /^\s+\#/;
            next if /^\s*$/;
            if (m%^/(.*)/\s*$%) {
                my $regex = $1;
                $found = ($volume =~ /$regex/);
            } elsif ($found && /^\s/) {
                my ($user, $acl, $bogus) = split;
                if ($bogus || !$user || !$acl) {
                    warn "$0: syntax error on line $. of $ACLS\n";
                    next;
                }
                push (@extra, $user, $acl);
            }
        }
        close ACLS;
    } else {
        warn "$0: cannot open $ACLS: $!\n";
    }

    # Append the extra ACLs that apply to this volume.
    push (@acls, @extra);

    # Actually set the ACLs.
    system ($FS, 'setacl', $mtpt, @acls) == 0
        or warn 'Failed to set acls (status ', ($? >> 8), ")\n";
}

# Given the volume name and then a list of server and partition pairs, create
# the replicas for a replicated volume and then release it.  The list of
# server and partition pairs must include the location of the read/write
# volume for the first replica.
sub volume_replicate {
    my ($volume, @locations) = @_;
    while (@locations) {
        my ($server, $partition) = @{ shift @locations };
        system ($VOS, 'addsite', $server, $partition, $volume) == 0
            or die "Failed to replicate volume to $server $partition",
                ' (status ', ($? >> 8), ")\n";
    }
    system ($VOS, 'release', '-f', $volume) == 0
        or die 'Failed to release volume (status ', ($? >> 8), ")\n";
}

##############################################################################
# Main routine
##############################################################################

# Trim extraneous garbage from the path.
my $fullpath = $0;
$0 =~ s%.*/%%;

# Parse command line options.  We do allow an odd number of arguments for
# ACLs, in order to allow things like -clear.
my ($clone, $help, $replicas, $type, $version);
Getopt::Long::config ('bundling', 'no_ignore_case', 'require_order');
GetOptions ('clone|c=s'            => \$clone,
            'help|h'               => \$help,
            'dry-run|just-print|n' => \$JUSTPRINT,
            'replicas|r=i'         => \$replicas,
            'type|t=s'             => \$type,
            'version|v'            => \$version) or exit 1;
if ($help) {
    print "Feeding myself to perldoc, please wait....\n";
    exec ('perldoc', '-t', $0) or die "Cannot fork: $!\n";
} elsif ($version) {
    my $version = join (' ', (split (' ', $ID))[1..3]);
    $version =~ s/,v\b//;
    $version =~ s/(\S+)$/($1)/;
    $version =~ tr%/%-%;
    print $version, "\n";
    exit 0;
}
if ($replicas && !$type) { die "-r option given without -t option\n" }
$replicas ||= 0;

# Fill in the various information that we need.
my ($server, $partition, $volume, $quota, $mtpt, @acls);
if ($type) {
    die "Usage: volcreate -t type volname quota mountpoint [acls]\n"
        if @ARGV < 3;
    ($volume, $quota, $mtpt, @acls) = @ARGV;
} else {
    die "Usage: volcreate server partition volname quota mtpt [acls]\n"
        if (@ARGV < 5);
    ($server, $partition, $volume, $quota, $mtpt, @acls) = @ARGV;
}

# Because we're loading the mount point database, we need the mount point
# specified in the correct fashion.  This also catches most of the cases of
# missing an argument or getting the arguments in the wrong order.
die "Mount point must begin with /afs/.ir/\n" unless $mtpt =~ m%^/afs/.ir/%;

# fs mkm doesn't like trailing slashes on the mount point, and neither does
# the mount point database.
$mtpt =~ s%/+$%%;

# Canonify AFS server name and find the exact partition on which to create the
# read/write volume.
my @ros;
if ($type) {
    if ($replicas) {
        @ros = find_best_replicated ($type, $replicas);
        ($server, $partition) = @{ $ros[0] };
    } else {
        ($server, $partition) = find_best_normal ($type);
    }
} else {
    ($server, $partition) = @{ (find_targets [ $server, $partition ])[0] };
}

# Do the work of creating and mounting the read/write volume.
if ($clone) {
    volume_clone ($server, $partition, $volume, $clone);
} else {
    volume_create ($server, $partition, $volume, $quota);
}
volume_mount ($volume, $mtpt);
unless ($clone) {
    volume_setacls ($volume, $mtpt, @acls);
}

# If the volume is replicated, take care of creating and releasing the
# replicas now that the ACL is set correctly.
if ($replicas && $replicas > 0) {
    volume_replicate ($volume, @ros);
}
exit 0;
__END__

##############################################################################
# Documentation
##############################################################################

=head1 NAME

volcreate - Create and mount a new AFS volume

=head1 SYNOPSIS

B<volcreate> [B<-hvn>] [B<-c> I<clone-from>] I<server> I<part> I<volume>
I<quota> I<mount> [I<acl> ...]

B<volcreate> [B<-hvn>] [B<-c> I<clone-from>] B<-t> I<type>
[B<-r> I<replicas>] I<volume> I<quota> I<mount> [I<acl> ...]

=head1 DESCRIPTION

B<volcreate> creates a new AFS volume on the given server and partition,
sets its quota, and mounts it in the file system at the given path,
optionally setting its ACL.  It then updates the AFS mount point database to
include this new volume.

I<server> is the AFS server on which to create the volume.  AFS servers may
be specified as just a number; all numeric server names will have C<afssvr>
prepended to them.

I<part> is the partition on which to create that volume.  Partitions may be
specified as a simple letter, as C<vicepX>, or as C</vicepX>.  More than 26
partitions on one server is not supported.  Partitions may also be specified
as C<.>, in which case the parition on that server with the most free space
according to B<vos partinfo> is chosen, or as a string of letters and letter
ranges such as C<ace-gm>, in which case the partition of the set specified
with the most free space is chosen.  (In this example, the set is /vicepa,
/vicepc, /vicepe through /vicepg, or /vicepm on the given sever.)

Alternately, rather than giving a server and partition, B<volcreate> accepts
the B<-t> option to specify a volume type.  If this option is given, no
server or partition is necessary and B<volcreate> will instead place the
volume on an appropriate server by finding the partition with the most
percentage space free of the available servers for that volume type.  When
B<-t> is given, B<-r> may also be given to specify a number of replicas if a
replicated volume is being created.

I<volume> is the name of the volume to create.  I<quota> is its quota in
megabytes (B<not> in kilobytes).  I<mount> is the full path to the intended
mount location of the volume (this must begin with "/afs/.ir/" so that the
mount point database remains consistent).  I<acl> is any normal ACL
arguments to C<fs setacl>.

For some types of volumes, some ACLs will be set automatically.  This is
governed by the F<acl-rules> file; see L<FILES> below.

=head1 OPTIONS

=over 4

=item B<-c> I<clone-from>, B<--clone>=I<clone-from>

Rather than creating a new, empty volume, clone the newly created volume
from the volume I<clone-from>.  This dumps the old volume into F</tmp>, so
be careful to do this on a system with a lot of space in F</tmp> if the
volume is large.  When this option is specified, the quota and ACLs
specified on the command line will be ignored, since they'll just be
copied from the old volume.  (The quota must still be specified, though,
even though it's ignored.  This is a wart in the interface.)

=item B<-h>, B<--help>

Print out this documentation (which is done simply by feeding the script
to C<perldoc -t>).

=item B<-n>, B<--dry-run>, B<--just-print>

Don't run any commands, just print out what would have been done.

=item B<-r> I<replicas>, B<--replicas>=I<replicas>

The number of replicas for the volume.  Use of this option indicates that
the volume is replicated, and it will be replicated at a number of sites
equal to the I<replicas> value.  The first replica will always be on the
same server and partition as the read/write volume; the rest will be chosen
from the servers that hold read-only replicas for that volume type.  B<-t>
must be given if this option is used.

=item B<-t> I<type>, B<--type>=I<type>

Create a volume of the specified type.  When this option is used, no server
or partition should be specified, and instead B<volcreate> will find all the
servers that can store that volume type and pick the server and partition
with the most percentage space free.  This option is required to use B<-r>.

=item B<-v>, B<--version>

Print out the version of B<volcreate> and quit.

=back

=head1 EXAMPLES

Create the volume ls.mail.logs on afssvr14 /vicepa with a quota of 20MB and
mount it on /afs/.ir/site/leland/mail/logs:

    volcreate afssvr14 a ls.mail.logs 20 /afs/.ir/site/leland/mail/logs

Create ls.trip.nntp on afssvr3 /vicepc with a quota of 5MB and mount it on
/afs/.ir/site/leland/tripwire/nntp.Stanford.EDU.  Set a default ACL only
giving system:localhosts read access and rra all access.

    volcreate 3 c ls.trip.nntp 5 \
        /afs/.ir/site/leland/tripwire/nntp.Stanford.EDU \
        -clear system:localhosts read rra all

(this should all be typed on one line).  Note that C<fs setacl> flags like
-clear are allowed.

Create a replicated volume with three replicas of type pubsw named
pubsw.byacc19 with a quota of 20MB and mount it at
/afs/.ir/pubsw/Languages/byacc-1.9.

    volcreate -t pubsw -r 3 pubsw.byacc19 20 \
        /afs/.ir/pubsw/Langauges/byacc-1.9

The correct ACLs for a pubsw volume will be set based on the F<acl-rules>
file.

Clone ls.trip.nntp into a new ls.trip.news volume, which will be mounted
at /afs/.ir/site/leland/tripwire/news.Stanford.EDU:

    volcreate -t logs -c ls.trip.nntp ls.trip.news 0 \
        /afs/.ir/site/leland/tripwire/news.Stanford.EDU

Note that the meaningless 0 quota value is ignored.

=head1 FILES

=over 4

=item F</afs/ir/service/afs/data/serverlist.types>

The default path to a file containing a list of current AFS servers and
their volume types.  Each line should start with an AFS server name,
optionally a location for that server in square brackets, and then
optionally contain a space-separated list of types of volumes handled by
that server.  Those volume types may begin with a single letter or range of
letters and a colon, indicating that only the partition or partitions named
handle that type of volume.

For non-replicated volumes, the type in this file should match the type
given to B<volcreate>.  For replicated volumes, the type suffixed with
C<-rw> will be used for the read/write volume and the type suffixed with
C<-ro> will be used for the replicas.

So, for example, a sample entry would be:

    afssvr11 [sweet] a-c:logs d:pubsw-ro d:web-ro

When creating replicated volumes, B<volcreate> will attempt to put at least
one replica in every distinct location that accepts the C<-ro> version of
that volume type.

=item F</afs/ir/service/afs/data/acl-rules>

This file contains rules specifying the default ACLs that should be set on
different types of volumes.  The format of this file should be a regular
expression matching a class of volumes, surrounded by // and starting in the
first column, and then followed by whitespace-indented user/ACL pairs that
apply to that class of volumes, one per line.  All matching regular
expressions will contribute their set of ACL settings to the final ACL
string.  Any ACLs given on the command line of volcreate will take
precedence over the ones in this file (but the ones in this file will still
be applied -- the ACLs will be merged).

A sample entry would be:

    /^(group|dept)\./
        system:anyuser read
        system:dept-admin all

Note that the regex line must not be indented (must begin in column one),
and the ACL lines must be indented.  Think of it as Python.

=back

=head1 SEE ALSO

L<vos_create(1)>, L<vos_dump(1)>, L<vos_restore(1)>, L<fs_mkmount(1)>,
L<fs_setquota(1)>, L<fs_setacl(1)>

The current version of this program is available from its web page at
L<http://www.eyrie.org/~eagle/software/volcreate/>.

=head1 AUTHORS

Neil Crellin <neilc@stanford.edu> and Russ Allbery <rra@stanford.edu>.

=head1 COPYRIGHT AND LICENSE

Copyright 1998, 1999, 2000, 2002, 2004 Board of Trustees, Leland Stanford
Jr. University.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut
